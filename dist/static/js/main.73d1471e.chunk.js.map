{"version":3,"sources":["serviceWorker.js","constants.ts","utility/index.ts","utility/request.ts","components/Misc.tsx","context.ts","browser_utils/index.ts","components/ConnectForm.tsx","sites/index.js","components/DownloadInput.tsx","components/App.tsx","index.tsx","sites/ehentai.js","misc/happypandax.svg"],"names":["Boolean","window","location","hostname","match","unregister","navigator","serviceWorker","ready","then","registration","IS_POPUP_CONTEXT","hash","IS_BACKGROUND_CONTEXT","MESSAGES","popup","undefined","background","BACKGROUND_STATE","connected","session","server","popup_connected","native_fetch","fetch","url","props","def_props","credentials","method","json","body","headers","Object","assign","JSON","stringify","fetch_props","callFunction","name","args","prepared_data","data","fname","r","a","ok","r_data","error","d","Array","isArray","console","log","downloadUrl","urls","Error","ErrorMessage","className","children","AppContext","React","createContext","onConnect","state","opt","setError","hasSitePermission","site","browser","permissions","contains","origins","hasPermission","p","hasWebNavPermission","loadContentScript","matcher","script","contentScripts","register","code","getStorageValue","keys","single","storage","local","get","clearStorage","clear","setStorageValue","values","set","getActiveTabUrl","tabs","query","currentWindow","active","t","getActiveTabId","id","getBagde","text","activeTab","browserAction","tabId","getBadgeText","setBadge","color","setBadgeBackgroundColor","setBadgeTextColor","setBadgeText","ConnectForm","appcontext","useContext","useState","loading","set_loading","set_error","def_username","set_def_username","def_password","set_def_password","def_server","set_def_server","set_response_error","status","statusText","checkLogin","username","password","server_endpoint","r2","serv_data","catch","err","message","useEffect","info","onSubmit","ev","preventDefault","fdata","FormData","target","endsWith","slice","placeholder","defaultValue","type","require","default","test","gallery","getGalleryUrl","u","sites","m","RegExp","DownloadButton","added","DownloadCurrentUrlButton","set_added","onClick","current_url","DownloadInput","set_url","msg","set_msg","value","onChange","DisconnectButton","SupportedSites","s","join","data-tooltip","data-position","Footer","href","DebugFooter","checkGalleryUrlExists","recheck","includes","replace","CheckExists","exists","set_exists","check","updateGalleryStatus","NotAvailable","Buttons","available","set_available","loadContentScripts","onContextMenu","tab","menuItemId","linkUrl","pageUrl","_gallery","onSiteNav","details","onPopupMessage","setState","onBgMessage","_setup","App","set_connected","set_server","set_session","version","set_version","header_text","set_header_text","set_ready","b","runtime","addListener","setTimeout","connect","onMessage","postMessage","visited_sites","push","permissionPage","create","getURL","onClicked","removeListener","onUpdateAvailable","reload","webNavigation","onDOMContentLoaded","urlMatches","menus","title","contexts","onclick","documentUrlPatterns","targetUrlPatterns","lastError","manifest","getManifest","Provider","opts","cfg","src","hpxsvg","alt","global","chrome","ReactDOM","render","document","getElementById","module","exports"],"mappings":"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","file":"static/js/main.73d1471e.chunk.js","sourcesContent":["// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","export let DEFAULT_HPX_SERVER = \"http://localhost:7008\"\nexport let HPX_SERVER_ENDPOINT_PATH = \"/server/\"\nexport let DEFAULT_HPX_SERVER_ENDPOINT = DEFAULT_HPX_SERVER + HPX_SERVER_ENDPOINT_PATH\nexport let HPX_CLIENT_NAME = \"hpx-browser-extension\"\n\nexport const IS_POPUP_CONTEXT = typeof window !== 'undefined' ? window.location.hash === '#popup' : false\nexport const IS_BACKGROUND_CONTEXT = typeof window !== 'undefined' ? window.location.hash === '#background' : false\n\nexport const DEBUG = true\n\nexport const MESSAGES = {\n    popup: undefined as browser.runtime.Port,\n    background: undefined as browser.runtime.Port\n}\n\nexport let BACKGROUND_STATE = {\n    connected: false,\n    session: \"\",\n    server: \"\",\n    popup_connected: false // i.e. popup has connected to the background page\n}\n\nexport const HPX_CONTEXTMENU_DOWNLOAD_THIS_GALLERY_ID = \"happypandax-download-this-gallery\"","export const native_fetch = fetch;","import { native_fetch } from '.'\nimport { HPX_CLIENT_NAME, BACKGROUND_STATE } from '../constants'\n\nexport const getJson = (msg) => {\n    return JSON.parse(msg)\n}\n\ninterface FetchInit extends Omit<RequestInit, 'body'> {\n    body?: string | object\n    json?: boolean\n}\n\nexport const fetch = (url, props: FetchInit = {}) => {\n    let def_props: FetchInit = {\n        credentials: \"include\",\n        method: 'post',\n    }\n\n    if (props.json || typeof props.body === 'object') {\n        def_props.headers = Object.assign(def_props.headers || {}, props.headers || {}, {\n            'Accept': 'application/json',\n            'Content-Type': 'application/json'\n        })\n        \n        if (typeof props.body !== 'string') {\n            props.body = JSON.stringify(props.body)\n        }\n    }\n    \n    delete props.json\n    \n    let fetch_props: RequestInit = Object.assign(def_props, props)\n\n    return native_fetch(url, fetch_props)\n}\n\nexport const callFunction = (name: string, args: object, {session = undefined as string, server = undefined as string} = {}) => {\n    let prepared_data = {\n        session: session || BACKGROUND_STATE.session,\n        name: HPX_CLIENT_NAME,\n        data: [{fname: name, ...args}]\n    }\n    return fetch(server || BACKGROUND_STATE.server, {method:\"post\", json: true, body: prepared_data}).then(async (r) => {\n        let d\n        if (r.ok) {\n            let r_data = await r.json()\n            if (!r_data.error && r_data.data) {\n                d = r_data.data\n                if (Array.isArray(d)) {\n                    d = d[0]\n                }\n            } else {\n                console.log(r_data)\n                // do something\n            }\n        }\n        return d\n    })\n}\n\nexport const downloadUrl = async (urls: string[]) => {\n    let r = await callFunction(\"add_urls_to_download_queue\", {urls})\n    if (!r.error) {\n        if (r.data) { \n            return true\n        }\n    } else {\n        throw Error(r.error)\n    }\n    return false\n}","import React from 'react';\n\nexport const ErrorMessage = (props) => {\n    return (\n        <div className=\"ui error message\">{props.children}</div>\n    )\n}","import React from 'react';\n\nimport { BACKGROUND_STATE } from './constants'\n\nexport interface ConnectOpts {\n    server?: string\n    session?: string\n    username?: string\n    password?: string\n}\n\nexport const AppContext = React.createContext({\n    server: BACKGROUND_STATE.server,\n    session: BACKGROUND_STATE.session,\n    connected: false,\n    onConnect: (state, opt?: ConnectOpts) => {},\n    setError: (error: string) => {}\n})","export const askSitePermission = async (site: string | string[]) => {\n    try {\n        if (browser) {\n            let s\n            if (typeof site === 'string') {\n                s = [site]\n            }\n            return await browser.permissions.request({origins: s})\n        }\n        return false\n    } catch(err) {\n        console.error(err)\n        throw err\n    }\n}\n\nexport const hasSitePermission = async (site: string) => {\n    if (browser) {\n        return await browser.permissions.contains({origins: [site]})\n    }\n    return false\n}\n\nexport const askPermission = async (p: browser.permissions.Permission[]) => {\n    if (browser) {\n        return await browser.permissions.request({permissions: p})\n    }\n    return false\n}\n\nexport const hasPermission = async (p: browser.permissions.Permission[]) => {\n    if (browser) {\n        return await browser.permissions.contains({permissions: p})\n    }\n    return false\n}\n\nexport const askTabsPermission = () => askPermission([\"tabs\"])\nexport const hasTabsPermission = async () => hasPermission([\"tabs\"])\n\nexport const askWebNavPermission = () => askPermission([\"webNavigation\"])\nexport const hasWebNavPermission = async () => hasPermission([\"webNavigation\"])\n\nexport const reload = () => {\n    if (browser) {\n        browser.runtime.reload()\n    }\n}\n\nexport const loadContentScript = async (matcher: string, script: string) => {\n    if (await hasSitePermission(matcher) && script) {\n      browser.contentScripts.register({\n        \"matches\": [matcher],\n        \"js\": [{code: script}]\n      })\n      return true\n    }\n    return false\n}\n\nexport const getStorageValue = async (keys: string | string[]) => {\n    let single = typeof keys === \"string\"\n    if (browser) {\n\n        let r = await browser.storage.local.get(keys)\n        return single ? r[keys as string] : r as object\n    }\n    return single ? undefined : {}\n}\n\nexport const clearStorage = async () => {\n    if (browser) {\n        return await browser.storage.local.clear()\n    }\n}\n\n\nexport const setStorageValue = async (values: browser.storage.StorageObject) => {\n    if (browser) {\n        return await browser.storage.local.set(values)\n    }\n}\n\nexport const getActiveTabUrl = async () => {\n    if (browser) {\n        let tabs = await browser.tabs.query({currentWindow: true, active: true})\n        let t = tabs[0]\n        return t ? t.url : \"\"\n    }\n    return \"\"\n}\n\nexport const getActiveTabId = async () => {\n    if (browser) {\n        let tabs = await browser.tabs.query({currentWindow: true, active: true})\n        let t = tabs[0]\n        return t ? t.id : undefined\n    }\n    return undefined\n}\n\nexport const getBagde = async ({ text = true, activeTab = true } = {}) => {\n    return {\n        text: text ? await browser.browserAction.getBadgeText({tabId: activeTab ? await getActiveTabId() : undefined}) : undefined\n    }\n}\n\nexport const setBadge = async ({text = undefined as string, color = undefined as string, background = undefined as string, activeTab = true} = {}) => {\n    browser.browserAction.setBadgeBackgroundColor({color: background || \"white\", tabId: activeTab ? await getActiveTabId() : undefined})\n    browser.browserAction.setBadgeTextColor({color: color || \"black\",  tabId: activeTab ? await getActiveTabId() : undefined})\n    if (text !== undefined) {\n        browser.browserAction.setBadgeText({text,  tabId: activeTab ? await getActiveTabId() : undefined})\n    }\n}","import React, { useState, useContext, useEffect } from 'react';\nimport { DEFAULT_HPX_SERVER, HPX_SERVER_ENDPOINT_PATH } from '../constants'\nimport { fetch } from '../utility/request';\nimport { ErrorMessage } from './Misc';\nimport { AppContext } from '../context';\nimport { setStorageValue, getStorageValue } from '../browser_utils';\n\nconst ConnectForm = () => {\n    \n    const appcontext = useContext(AppContext)\n    const [loading, set_loading] = useState(false)\n    const [error, set_error] = useState(\"\")\n    const [def_username, set_def_username] = useState(\"\")\n    const [def_password, set_def_password] = useState(\"\")\n    const [def_server, set_def_server] = useState(\"\")\n\n    const set_response_error = r => set_error(`Failed to connect to server (${r.status}): ${r.statusText}`)\n\n    const checkLogin = (server, username, password) => {\n        let server_endpoint = server + HPX_SERVER_ENDPOINT_PATH\n        fetch(server_endpoint, {method: \"head\"}).then(async (r) => {\n            if (r.ok) {\n                const r2 = await fetch(server_endpoint, {method: \"post\", body: {username, password}})\n                set_loading(false)\n                if (r2.ok) { //\n                    let serv_data = await r2.json()\n                    if (serv_data.error) {\n                        if (serv_data.code && serv_data.code === 411) {\n                            set_error(\"Wrong credentials\")\n                        } else {\n                            set_error(serv_data.error)\n                        }\n                    } else {\n                        if (serv_data.data === \"Authenticated\") {\n                            setStorageValue({\n                                server,\n                                username,\n                                password\n                            })\n    \n                            appcontext.onConnect(true, {server:server_endpoint, username, password, session: serv_data.session})\n    \n                        } else {\n                            set_error(`Received a weird response: ${JSON.stringify(serv_data)}`)\n                        }\n                    }\n                } else {\n                    if (r2.status === 404) {\n                        set_error(\"The server might have disabled the communication endpoint (enable it in HPX config with server.enable_http_endpoint)\")\n                    } else {\n                        set_response_error(r2)\n                    }\n                }\n            } else {\n                set_response_error(r)\n                set_loading(false)\n            }\n        }).catch(err => {\n            set_loading(false)\n            set_error(`An error occured: ${err.message}`)\n        })\n    }\n\n    useEffect(() => {(async () => {\n        let info = await getStorageValue([\"username\", \"password\", \"server\"]) as any\n        if (info.server && info.username) {\n            checkLogin(info.server, info.username, info.password)\n        }\n        set_def_server(info.server)\n        set_def_username(info.username)\n        set_def_password(info.password)\n      })()}, [])\n    \n\n    return (\n        <form id=\"connect-form\" className={`ui form ${error ? \"error\" : \"\"}`} onSubmit={ev => {\n            ev.preventDefault()\n            set_error(\"\")\n            set_loading(true)\n            let fdata = new FormData(ev.target as HTMLFormElement)\n            let server = fdata.get(\"server\") as string\n            if (!server) {\n                server = DEFAULT_HPX_SERVER\n            }\n            if (server.endsWith(\"/\")) {\n                server = server.slice(0, -1)\n            }\n            \n            let username = fdata.get(\"username\") as string || \"default\"\n            let password = fdata.get(\"password\") as string\n            checkLogin(server, username, password)\n        }}>\n            <div className=\"field\">\n                <label>HPX Web Server Host</label>\n                <div className=\"ui input\"><input placeholder=\"http://localhost:7008\" defaultValue={def_server} type=\"text\" name=\"server\"/></div>\n            </div>\n            <div className=\"field\">\n                <label>Username</label>\n                <div className=\"ui input\"><input placeholder=\"default\" type=\"text\" defaultValue={def_username} name=\"username\"/></div>\n            </div>\n            <div className=\"field\">\n                <label>Password</label>\n                <div className=\"ui input\"><input placeholder=\"\" type=\"password\" defaultValue={def_password} name=\"password\"/></div>\n            </div>\n            {!!error && <ErrorMessage>{error}</ErrorMessage>}\n            <p>\n                <button type=\"submit\" className={`ui basic button right floated ${loading ? \" loading\" : \"\"}`}>Connect</button>\n            </p>\n        </form>\n    );\n};\n\nexport default ConnectForm;","/* eslint-disable import/no-webpack-loader-syntax */\n\n// matcher : object\n\nexport default {\n    \"*://e-hentai.org/*\": { // match pattern url, used to ask for site permission and match for the contextmenu items\n        code: require(\"!raw-loader!../sites/ehentai\").default, // content-script code that should be injected\n        test: \".*//(www\\\\.)?e-hentai\\\\.org/.*$\", // different than the match pattern above, this is a regex expression to test if the site matches\n        gallery: \".*//(www\\\\.)?e-hentai\\\\.org/g/[0-9]{3,10}/[0-9a-zA-Z]{3,15}/?$\", // this is used to test if a url is a gallery\n    },\n    \"*://exhentai.org/*\": {\n        code: require(\"!raw-loader!../sites/ehentai\").default,\n        test: \".*//(www\\\\.)?exhentai\\\\.org/.*$\",\n        gallery: \".*//(www\\\\.)?exhentai\\\\.org/g/[0-9]{3,10}/[0-9a-zA-Z]{3,15}/?$\",\n    },\n    \"*://panda.chaika.moe/*\": {\n        code: \"\",\n        test: \".*//(www\\\\.)?panda\\\\.chaika\\\\.moe/.*$\",\n        gallery: \".*//(www\\\\.)?panda\\\\.chaika\\\\.moe/(gallery|archive)/[0-9]{3,15}/?$\",\n    },\n    \"*://nhentai.net/*\": {\n        code: \"\",\n        test: \".*//(www\\\\.)?nhentai\\\\.net/.*$\",\n        gallery: \".*//(www\\\\.)?nhentai\\\\.net/g/[0-9]{3,10}/?$\",\n    },\n}\n","import React, { useState, useEffect, useContext } from 'react';\nimport { callFunction, downloadUrl } from '../utility/request';\nimport { getActiveTabUrl } from '../browser_utils';\nimport sites from '../sites';\n\n// browser.commands.onCommand.addListener(function (command) {\n//     if (command === \"download-this-gallery\") {\n//       console.log(\"Downloading this gallery\");\n//     }\n//   });\n  \nexport const getGalleryUrl = async () => {\n    let u = await getActiveTabUrl()\n    let r = \"\"\n    for (let m in sites) {\n        if (sites[m].gallery) {\n            let reg = new RegExp(sites[m].gallery)\n            if (reg.test(u)) {\n                r = u\n                break\n            }\n        }\n    }\n    return r\n}\n\nexport const DownloadButton = ({ added = false, loading = false, children = undefined, ...props}) => {\n\n    return (\n        <button {...props} className={`ui basic button ${!children ? \"icon\" : \"\"} ${added ? \"green\" : \"primary\"} ${loading ? \"loading\" : \"\"}`}>\n            <i className={`icon ${added ? \"check\" : \"download\"}`}></i>\n            {children}\n        </button>\n    );\n};\n\nexport const DownloadCurrentUrlButton = () => {\n\n    const [added, set_added] = useState(false)\n    const [loading, set_loading] = useState(false)\n\n    return (\n        <DownloadButton added={added} loading={loading} onClick={async ev => {\n            ev.preventDefault()\n            let current_url = await getGalleryUrl()\n            if (current_url) {\n                set_loading(true)\n                downloadUrl([current_url]).then(r => {\n                    set_loading(false)\n                    set_added(r)\n                })\n            }\n        }}>\n            {added ? \"Sent!\" : \"Download this gallery\"}\n        </DownloadButton>\n    );\n};\n\nconst DownloadInput = () => {\n\n    const [url, set_url] = useState(\"\")\n    const [msg, set_msg] = useState(\"\")\n    const [added, set_added] = useState(false)\n    const [loading, set_loading] = useState(false)\n\n\n    useEffect(() => {(async () => {\n        if (!url) {\n            set_url(await getActiveTabUrl())\n        }\n    })()\n    }, [])\n\n\n    return (\n        <form className=\"ui form\" onSubmit={ev => {\n            ev.preventDefault()\n            set_added(false)\n            if (url) {\n                set_loading(true)\n                downloadUrl([url]).then(r => {\n                    set_loading(false)\n                    if (r) {\n                        set_url(\"\")\n                        set_added(true)\n                    }\n                }).catch(err => {set_loading(false); set_msg(err.message)})\n            }\n        }}>\n            <div className=\"field\">\n                <div className=\"ui action input\">\n                    <input value={url} onChange={(ev) => { ev.preventDefault(); set_url(ev.target.value)}} type=\"text\" placeholder=\"URL\"/>\n                    <DownloadButton type=\"submit\" added={added} loading={loading}/>\n                </div>\n            </div>\n            <p className=\"text-center\">\n                {msg}\n            </p>\n        </form>\n    );\n};\n\nexport default DownloadInput;","import React, { useContext, useState, useEffect } from 'react';\nimport hpxsvg from '../misc/happypandax.svg'\nimport ConnectForm from './ConnectForm';\nimport { AppContext, ConnectOpts } from '../context';\nimport { IS_POPUP_CONTEXT, IS_BACKGROUND_CONTEXT, DEBUG, MESSAGES, BACKGROUND_STATE, HPX_CONTEXTMENU_DOWNLOAD_THIS_GALLERY_ID } from '../constants'\nimport { callFunction, downloadUrl } from '../utility/request';\nimport DownloadInput, { DownloadCurrentUrlButton, getGalleryUrl } from './DownloadInput';\nimport { ErrorMessage } from './Misc';\nimport { askSitePermission, askTabsPermission, hasTabsPermission, hasSitePermission, reload, loadContentScript, getStorageValue, setStorageValue, clearStorage, hasWebNavPermission, askWebNavPermission, getActiveTabId, setBadge, getBagde, getActiveTabUrl } from '../browser_utils';\nimport sites from '../sites'\n\nimport './App.css';\n\nconst DisconnectButton = () => {\n  const appcontext = useContext(AppContext)\n\n  return (\n    <button className=\"ui button mini icon\" onClick={ev => {\n      ev.preventDefault();\n      appcontext.onConnect(false)\n      setStorageValue({\n        username: \"\",\n        password: \"\"\n      })\n      }}>\n      <i className=\"sign-out flipped icon\"></i>\n    </button>\n  )\n}\n\nconst SupportedSites = () => {\n\n  const s = Object.keys(sites).join(\" | \")\n\n  return (\n    <div className=\"ui label\" data-tooltip={s} data-position=\"top left\">\n      <i className=\"globe icon\"></i>\n      Sites\n    </div>\n  )\n}\n\nconst Footer = () => {\n  const appcontext = useContext(AppContext)\n\n  return (\n    <div className=\"ui segment secondary\">\n      {appcontext.connected && <DisconnectButton/>}\n      <SupportedSites/>\n      <a className=\"ui label\" href=\"https://github.com/happypandax/extension/issues\">\n        <i className=\"bug icon\"></i> Find an issue?\n      </a>\n      <a className=\"ui label basic float-right\" href=\"https://github.com/happypandax/extension\">\n        <i className=\"code icon\"></i> Source\n      </a>\n      <a className=\"ui label basic teal float-right\" href=\"https://github.com/happypandax/happypandax\">\n        <i className=\"github icon\"></i> HappyPanda X\n      </a>\n    </div>\n  )\n}\n\nconst DebugFooter = () => {\n  const appcontext = useContext(AppContext)\n\n  return (\n    <div className=\"ui segment tertiary\">\n      <button className=\"ui button basic mini\" onClick={clearStorage}>Clear storage</button>\n    </div>\n  )\n}\n\nconst checkGalleryUrlExists = async (url: string, recheck=true) => {\n  let r = await callFunction(\"gallery_exists\", {url})\n  if (!r.error) {\n    if (r.data === true) {\n      return true\n    } else if (r.data === false) {\n      if (recheck) {\n        if (url.includes(\"e-hentai.org/g/\")) {\n          return await checkGalleryUrlExists(url.replace(\"e-hentai.org/g/\", \"exhentai.org/g/\"), false)\n        } else if (url.includes(\"exhentai.org/g/\")) {\n          return await checkGalleryUrlExists(url.replace(\"exhentai.org/g/\", \"e-hentai.org/g/\"), false)\n        }\n      }\n    }\n  } \n  return false\n}\n\nconst CheckExists = () => {\n\n  const [exists, set_exists] = useState(undefined)\n  const [loading, set_loading] = useState(false)\n\n  const check = async (ev, url: string) => {\n    if (ev) ev.preventDefault();\n    let current_url = url || await getGalleryUrl()\n    if (current_url) {\n      set_loading(true)\n      let r = await checkGalleryUrlExists(current_url)\n      set_exists(r)\n      set_loading(false)\n      updateGalleryStatus()\n    }\n  }\n\n  useEffect(() => {\n    getGalleryUrl().then(r => {\n      if (r) {\n        check(null, r)\n      }\n    })\n  }, [])\n\n  return (\n      <button className={`ui basic button ${loading ? \"loading\" : \"\"} ${exists === true ? \"green\" : exists === false ? \"red\" : \"teal\"}`} onClick={ev => check(ev, undefined)}>\n          <i className={`icon ${exists === true ? \"thumbs up\" : exists === false ? \"close\" : \"question\"}`}></i>\n          {exists === true ? \"Gallery already exists\" : exists === false ? \"Gallery does not exist\" : \"Check if this gallery exists\"}\n      </button>\n  );\n};\n\nconst NotAvailable = () => {\n  return (\n    <div className=\"ui placeholder segment not-available\">\n      <div className=\"ui icon header muted\">\n        <i className=\"dont icon\"></i>\n        Not available\n      </div>\n    </div>\n  )\n}\n\nconst Buttons = () => {\n\n  const [available, set_available] = useState(false)\n\n  useEffect(() => {\n    getGalleryUrl().then(r => set_available(!!r))\n  }, [])\n\n  return (\n    <>\n    {available &&\n    <div id=\"buttons\" className=\"ui basic segment secondary fluid\">\n      <div className=\"two ui buttons\">\n        <DownloadCurrentUrlButton/>\n        <CheckExists/>\n      </div>\n    </div>}\n    {!available && <NotAvailable/>}\n    </>\n  )\n}\n\nconst PermissionsSegment = ({show = false, onGrant = undefined, children = undefined}) => {\n  const appcontext = useContext(AppContext)\n\n  return (\n    <>\n    {show &&\n      <div className=\"ui segment red secondary\">\n        <span>\n          {children}\n          <span className=\"ml-2\">\n          <button className=\"ui button mini\" onClick={ ev => {\n            if (onGrant) {\n              try {\n                onGrant(true)\n              } catch (err) {\n                appcontext.setError(err.message)\n              }\n            }\n          }}>Grant</button>\n          <button className=\"ui button mini\" onClick={ev => {\n            if (onGrant) {\n              try {\n                onGrant(false)\n              } catch (err) {\n                appcontext.setError(err.message)\n              }\n            }\n          }}>Deny</button>\n          </span>\n        </span>\n      </div>\n    }\n    </>\n  )\n}\n\nconst AskTabsPermission = () => {\n  const [perm, set_perm] = useState(true)\n  useEffect(() => {\n    hasTabsPermission().then(r => set_perm(r))\n  }, [])\n\n  return (\n    <PermissionsSegment show={!perm} onGrant={(s) => {\n      if (s) {\n        askTabsPermission().then(r => {\n          if (r) {\n            set_perm(true)\n          }\n        })\n      }\n    }}>\n      This extension requires permission to access your tabs to be able to read your tab's URL\n    </PermissionsSegment>\n  )\n}\n\nconst AskWebNavPermission = () => {\n  const [perm, set_perm] = useState(true)\n  useEffect(() => {\n    hasWebNavPermission().then(r => set_perm(r))\n  }, [])\n\n  return (\n    <PermissionsSegment show={!perm} onGrant={(s) => {\n      if (s) {\n        askWebNavPermission().then(r => {\n          if (r) {\n            set_perm(true)\n          }\n        })\n      }\n    }}>\n      This extension requires permission to access navigation to know when a supported URL is encountered\n    </PermissionsSegment>\n  )\n}\n\nconst AskSitePermission = () => {\n  const site = \"*://e-hentai.org/*\"\n  const [perm, set_perm] = useState(true)\n  useEffect(() => {\n    hasSitePermission(site).then(r => set_perm(r))\n  }, [])\n\n  return (\n    <PermissionsSegment show={!perm} onGrant={async (s) => {\n      if (s) {\n        if (await askSitePermission(site)) {\n          set_perm(true)\n          await loadContentScript(site, sites[site].code)\n        }\n      }\n    }}>\n      Grant this extension the permission to access this site?\n    </PermissionsSegment>\n  )\n}\n\nconst AskAllSitesPermission = () => {\n  const key = \"all_sites_permission_denied\"\n  const [denied, set_denied] = useState(true)\n  const [perm, set_perm] = useState(true)\n  useEffect(() => {(async () => {\n    let s = true\n    for (let m in sites) {\n      if (!await hasSitePermission(m)) {\n        s = false\n        break\n      }\n    }\n    set_perm(s)\n    set_denied(await getStorageValue(key) as boolean || false)\n  })()}, [])\n\n  return (\n    <PermissionsSegment show={!perm && !denied} onGrant={async (s) => {\n      if (s) {\n        if (await askSitePermission(Object.keys(sites))) {\n          set_perm(true)\n          loadContentScripts()\n        }\n      } else {\n        set_denied(true)\n        let o = {}\n        o[key] = true\n        setStorageValue(o)\n      }\n    }}>\n      Grant this extension the permission to access all the supportes sites?\n    </PermissionsSegment>\n  )\n}\n\nconst loadContentScripts = async () => {\n  for (let matcher in sites) {\n    await loadContentScript(matcher, sites[matcher].code)\n  }\n}\n\nconst updateGalleryStatus = async () => {\n  let u = await getGalleryUrl()\n  if (u) {\n    if (await checkGalleryUrlExists(u)) {\n      await setBadge({text: \"✔\", color: \"green\", background: \"\"})\n    } else {\n      await setBadge({text: \"1\", color: \"\", background: \"\"})\n    }\n  }\n}\n\nconst onContextMenu = (info: browser.menus.OnClickData, tab: browser.tabs.Tab) => {\n  if (info.menuItemId === HPX_CONTEXTMENU_DOWNLOAD_THIS_GALLERY_ID) {\n    let url = info.linkUrl || info.pageUrl\n    if (url) {\n      for (let m in sites) {\n        let s = sites[m]\n        if (!s._gallery) {\n          s._gallery = new RegExp(s.gallery)\n        }\n        if (s._gallery.test(url)) {\n          checkGalleryUrlExists(url).then(r => {\n            if (!r) {\n              downloadUrl([url])\n              setBadge({text: \"S\", color: \"green\", background:\"\"})\n            } else {\n              setBadge({text: \"E\", color: \"red\", background:\"\"})\n            }\n          })\n        }\n      }\n    }\n  }\n}\n\nconst onSiteNav = async (site: any, details: any) => {\n  let visited_sites = await getStorageValue(\"visited_sites\") as any || []\n  if (!visited_sites.includes(site.test)) {\n    await setBadge({text: \"!\", color: \"red\", background: \"\"})\n  } else {\n    if (BACKGROUND_STATE.connected) {\n      await updateGalleryStatus()\n    }\n  }\n}\n\n// remember: no async\nconst onPopupMessage = (msg) => {\n  if (msg.setState) {\n    Object.assign(BACKGROUND_STATE, msg.setState)\n  }\n}\n\n// remember: no async\nconst onBgMessage = (msg) => {\n  if (msg.setState) {\n    Object.assign(BACKGROUND_STATE, msg.setState)\n  }\n}\n\nlet _setup = false\n\nconst App = () => {\n  \n  const [connected, set_connected] = useState(BACKGROUND_STATE.connected)\n  const [server, set_server] = useState(BACKGROUND_STATE.server)\n  const [session, set_session] = useState(BACKGROUND_STATE.session)\n  const [version, set_version] = useState(\"\")\n  const [error, set_error] = useState(\"\")\n  const [header_text, set_header_text] = useState(\"\")\n  const [ready, set_ready] = useState(IS_POPUP_CONTEXT ? false : true)\n\n  useEffect(() => {\n    if (browser) {\n      if (!connected && ready) {\n        setBadge({text:\"Off\", color:\"black\", background: \"red\"})\n      } else if (ready) {\n        getBagde({text: true}).then(b => {\n          if (b.text === 'Off') {\n            setBadge({text:\"\", color:\"\", background: \"\"})\n          }\n        })\n      }\n    }\n  }, [connected, ready])\n  \n  useEffect(() => {(async () => {\n    try {\n      if (!_setup) {\n        _setup = true\n        if (browser) {\n            if (IS_POPUP_CONTEXT) {\n              // setup message channel to background page\n              browser.runtime.onConnect.addListener(p => {\n              if (p.name === \"background\") {\n                setTimeout(() => {\n                  set_session(BACKGROUND_STATE.session)\n                  set_connected(BACKGROUND_STATE.connected)\n                  set_server(BACKGROUND_STATE.server)\n                  set_ready(true)\n                }, 100)\n              }})\n              MESSAGES.background = browser.runtime.connect({name:\"popup\"})\n              MESSAGES.background.onMessage.addListener(onPopupMessage)\n              MESSAGES.background.postMessage({setState: {popup_connected: true}})\n\n              // reset bagde on first time site visit\n              if ((await getBagde()).text === '!') {\n                setBadge({text: \"\", color: \"\"})\n                for (let m in sites) {\n                  if (new RegExp(sites[m].test).test(await getActiveTabUrl())) {\n                    let visited_sites = await getStorageValue(\"visited_sites\") as any || []\n                    visited_sites.push(sites[m].test)\n                    setStorageValue({visited_sites})\n                  }\n                }\n                set_header_text(\"This site is supported!\")\n              }\n\n              if ( [\"S\", \"E\"].includes((await getBagde()).text)) { // reset badge\n                setBadge({text: \"\", color: \"\"})\n              }\n\n            }\n            \n            if (IS_BACKGROUND_CONTEXT) {\n              const permissionPage = () => {\n                browser.tabs.create({\n                  url: browser.runtime.getURL(\"index.html\")\n                });\n                browser.browserAction.onClicked.removeListener(permissionPage)\n              }\n              browser.browserAction.onClicked.addListener(permissionPage);\n\n              // setup message channel to popup page page\n              browser.runtime.onConnect.addListener(p => {\n                if (p.name === \"popup\") {\n                  MESSAGES.popup = p\n                  p.onMessage.addListener(onBgMessage)\n                  browser.runtime.connect({name:\"background\"})\n                  setTimeout(() => {\n                    MESSAGES.popup.postMessage({setState: BACKGROUND_STATE})\n                  }, 50)\n                }\n              })\n\n              await loadContentScripts()\n\n              browser.runtime.onUpdateAvailable.addListener(() => { reload() })\n              if (await hasWebNavPermission()) {\n                for (let m of Object.keys(sites)) {\n                  browser.webNavigation.onDOMContentLoaded.addListener(r => onSiteNav(sites[m], r), {url: [{urlMatches: sites[m].test}]})\n                }\n              }\n\n              browser.menus.create({\n                id: HPX_CONTEXTMENU_DOWNLOAD_THIS_GALLERY_ID,\n                title: \"Download this gallery\",\n                contexts: [\"bookmark\", \"link\", \"page\", \"tab\"],\n                onclick: onContextMenu,\n                documentUrlPatterns: Object.keys(sites),\n                targetUrlPatterns: Object.keys(sites),\n              }, () => {\n                if (browser.runtime.lastError)\n                  console.error(`failed to create context menu: ${browser.runtime.lastError}`)\n              })\n                \n\n          }\n\n          let manifest = browser.runtime.getManifest()\n          set_version(manifest.version)\n        }\n      }\n    } catch (err) {\n      set_error(err.message)\n      if (IS_BACKGROUND_CONTEXT) {\n        console.error(err)   \n      }\n    }\n  })()}, [])\n\n  const onConnect = (state, opts: ConnectOpts) => {\n      set_connected(state)\n      BACKGROUND_STATE.connected = state\n      if (IS_POPUP_CONTEXT) {\n        MESSAGES.background.postMessage({setState: {connected: state}})\n      }\n\n      if (opts) {\n        BACKGROUND_STATE.server = opts.server || server\n        BACKGROUND_STATE.session = opts.session || session\n        \n        set_server(BACKGROUND_STATE.server)\n        set_session(BACKGROUND_STATE.session)\n\n        if (IS_POPUP_CONTEXT) {\n          MESSAGES.background.postMessage({setState: {session: BACKGROUND_STATE.session, server: BACKGROUND_STATE.server}})\n        }\n\n        if (BACKGROUND_STATE.connected) {\n          callFunction(\"set_config\", {cfg: {\n            \"download.skip_if_downloaded_before\": false,\n          }})\n        }\n\n      }\n\n  }\n\n  return (\n    <AppContext.Provider value={{\n      setError: set_error,\n      server,\n      session,\n      onConnect,\n      connected,\n    }}>\n      <>\n        {ready &&\n        <div className=\"ui segments browser-popup\">\n          {header_text && <div className=\"ui mini basic label green\">{header_text}</div>}\n          {version && <div className=\"ui top right attached mini basic label\">{version}</div>}\n          <div className=\"ui segment clearing\">\n            <div className=\"text-center\">\n              <img src={hpxsvg} className={`hpx-logo ${connected ? 'small' : ''}`} alt=\"logo\" />\n            </div>\n            {error && <ErrorMessage>{error}</ErrorMessage>}\n            {/* // CAN'T GET THIS TO WORK!! */}\n            {/* {connected && IS_POPUP_CONTEXT && <AskTabsPermission/>}\n            {connected && IS_POPUP_CONTEXT && <AskWebNavPermission/>}\n            {connected && IS_POPUP_CONTEXT && <AskAllSitesPermission/>}\n            {connected && IS_POPUP_CONTEXT && <AskSitePermission/>} */}\n            {!connected && <ConnectForm/>}\n            {connected && <div>\n              <Buttons/>\n              <div className=\"ui horizontal divider\">Or download URL</div>\n              <DownloadInput/>\n            </div>}\n          </div>\n          <Footer/>\n          {DEBUG && <DebugFooter/>}\n        </div>\n        }\n      </>\n    </AppContext.Provider>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nif (typeof !global.chrome === \"undefined\") {\n    global.browser = require(\"webextension-polyfill\")\n}\n\nif (typeof global.browser === \"undefined\") { // to make it work outside of add-on context\n    global.browser = null\n}\n\n/*eslint-disable */\nimport './index.css';\nimport App from './components/App';\nimport * as serviceWorker from './serviceWorker';\n/*eslint-enable */\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","export default \"\\nconst main = () => {\\n}\\n\\nmain()\\n\"","module.exports = __webpack_public_path__ + \"static/media/happypandax.2f9b3d92.svg\";"],"sourceRoot":""}